<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="generator" content="ReText 7.0.1">
<title>README</title>
</head>
<body>
<p><strong>VU Autonomous Racing Cars (2020S) - TU Wien</strong></p>
<p><strong>Team 3</strong></p>
<p>Stefan Adelmann | Hannes  Brantner | Daniel Lukitsch | Thomas Pintaric</p>
<hr>
<h1>Lab 8: Reinforcement Learning</h1>
<p>The eigth lab assignment had two distinct parts:</p>
<ol>
<li>The first part was to modify the existing but buggy <a href="https://github.com/f1tenth/f1tenth_gym"><strong>f1tenth_gym</strong></a> to our needs, to write a meaningful reward function that correctly shapes the agent policy, to define observation space and action space and to tune various parameters while training.</li>
<li>The second part was to test the trained model in a deployed ROS node, which communicates with the standard <a href="https://github.com/f1tenth/f1tenth_simulator"><strong>f1tenth_simulator</strong></a> and drives the racing car around different racing tracks.</li>
</ol>
<h2>Building and Running</h2>
<p>As the standard ROS Melodic installation only supports Python 2, and our chosen reinforcement learning framework <a href="https://github.com/tensorforce/tensorforce"><strong>Tensorforce</strong></a> only supports Python 3, we compiled a minimal ROS Melodic installation that supports Python 3 using the following scripts:</p>
<p>At first, change the current working directory to <strong>lab8/ros</strong> and verify that you have <a href="https://github.com/pyenv/pyenv"><strong>pyenv</strong></a> with Python 3.7.6 installed (<strong>check_prerequisites.sh</strong>). Then execute <strong>build_ros.sh</strong> to build a minimal ROS Melodic installtion with Python 3 support. Then execute the scripts <strong>build_f110_simulator.sh</strong> and <strong>build_racecar_agent.sh</strong> to build all required executables. After that execute <strong>run_f110_simulator.sh</strong> to start the simulator and then execute <strong>run_racecar_agent.sh</strong> to start our racecar agent for testing. There is also a <strong>clean<span>.sh</span></strong> scripts that removes all the files that were generated by the above scripts.</p>
<h2>Implementation details</h2>
<h3>Training</h3>
<p>Before the training script is started the required Python dependencies must be installed. This can be done with the following command:</p>
<pre><code class="bash">pip install -r lab8/gym/requirements.txt
</code></pre>

<p>We used an Actor-Critic <strong>PPO</strong> agent from <a href="https://github.com/tensorforce/tensorforce"><strong>Tensorforce</strong></a>, because it is able to work with an continuous action and observation space and additionally <strong>PPO</strong> also achieved better results than <strong>Deep-Q-Learning</strong> which was also tried, but later on dismissed. The model that is used for training and controlling the race-car consists of a convolutional neural network with two hidden layers each built with 64 neurons. The batch size was taken to be 10, therefore the parameters in the neural net are updated every tenth timestep. The agent was also initialized to introduce a little bit of action noise to enable a better state exploration in the long term.</p>
<p>The racecar agent was trained with a modified <a href="https://github.com/pintaric/f1tenth_simulator">f1tenth_simulator</a> and a modified <a href="https://github.com/pintaric/f1tenth_gym">f1tenth_gym</a> because the given sources were incomplete. The standard simulator used single-step forward integration to integrate the vehicle dynamics, but our modified simulator uses the Runge-Kutta Dormand-Prince method to integrate, which provides a much tighter error bound than the first one. The action space was continuous and the borders were passed with a parameter file. The number of laser scans that are observed can also be changed via a parameter in the respective file, but the default was to take every ninth ray resulting in 120 rays. The model was trained with the Python script <strong>lab8/gym/train_with_tensorforce.py</strong>. The reward per step is equivalent to the <strong>driven_distance</strong> added with the squared <strong>distance_from_obstacle</strong>, which are both read out by the position of the car in the simulator from the following cost maps:</p>
<p><img alt="" src="./f1_aut.driven_distances.colorized.png"></p>
<p>The above costmap described the distance in the direction of the goal that has been covered by the current position of the car.</p>
<p><img alt="" src="./f1_aut.distances_from_nearest_obstacle.colorized.png"></p>
<p>The above costmap described the distance to the nearest obstacle by the current position of the car.
These costmaps can be creates fully automatic by running the script <strong>lab8/costmaps/process_all_maps.bash</strong>.</p>
<p>If the car crashes into a wall the reward is decreased by 1000 and the episode is stopped. If the car travels more than 98% of the normalized driven distance, which is just the current driven distance according to the map divided by the maximum driven distance in the costmap, our algorithm detects a lap completion, increases the last reward by 1000000 and stops the current episode. The agent itself stops training after 10000 steps without completion of the current episodes. The training can only be stopped via a keyboard interrupt, but the model should be trained at least for 3000 episodes.</p>
<p>The following video shows the state space exploration during training:</p>
<p><img alt="" src="../slack/exploration_during_training.gif"></p>
<h3>Testing</h3>
<p>Our racecar agent automatically reads the shape of the observation space from the loaded <a href="https://github.com/tensorforce/tensorforce"><strong>Tensorforce</strong></a> model and subsamples the lidar scan accordingly to match the read shape. The racecar agent passes the correctly subsampled lidar scan to the model and asks it for the steering angle considering only the current observation. This steering angle is packed into a <strong>AckermannDriveStamped</strong> message where the steering angle is set accordingly to the model output and the velocity was fixed to <strong>1m/s</strong>. The racecar agent was tested on the map <strong>f1_mco.yaml</strong>, which is different to the map the model was trained (<strong>f1_aut.yaml</strong>) to also test the ability to generalize of the model. It should be considered that the Austrian map does not contain turnes as sharp as the Monaco map, therefore our agent crashes at sharp turnes, as you can see below.</p>
<p>The following picture shows the ROS Node Graph of our described configuration:</p>
<p><img alt="" src="../slack/rosgraph.png"></p>
<p>The next picture shows the racecar agent driving the car inside the simulator:</p>
<p><img alt="" src="../slack/image.png"></p>
<p>The following video shows the performance of the trained agent on the <strong>f1_mco.yaml</strong> racemap:</p>
<p><img alt="" src="../slack/driving_video.gif"></p>
<p>As can be seen in the previous video, the model generalizes pretty good and even avoids artificially added obstacles on the track. Nonetheless, the agent crashes in corner 5, because the track used for training has not contained such steep curves.</p>
</body>
</html>